---
title: 事件系统
top: false
cover: false
toc: true
date: 2023-07-28 17:05:16
tags:
- React
- JavaScript
password:
summary:
- React的事件系统、组件之间通信
categories:
- React
---
# 事件系统

虚拟dom在内存中以**对象**的形式存在，基于虚拟dom，实现了**SyntheticEvent（合成事件）**层，与原生事件拥有相同的接口，同样支持事件冒泡，可使用**stopPropagation(**)和**preventDefault()**中断。

## SyntheticEvent的绑定方式

- 驼峰式命名法命名属性（html为全部小写）
- props可以为任意属性（html只接收字符串）

## SyntheticEvent的实现机制

### 事件委派

事件代理机制，将所有的时间绑定到最外层，使用一个统一的**事件监听器**管理映射，当组件挂载卸载时，只需要在事件监听器上新增或者删除一些对象。当事件发生时，事件监听器先处理找到实际的事件函数调用，简化了**事件处理和回收机制，提升了效率。**

### 事件绑定

- **bind方法**

```javascript
<button onClick={this.btnClick.bind(this,'test')>
```

无传参时可简化：

```javascript
<button onClick={::this.btnClick}>
```

- **构造器内绑定**

```javascript
constructor{
  this.btnClick=this.btnClick.bind(this)
}
```

- **箭头函数**

```javascript
btnClick(e){}
<button onClick={()=>this.btnClick()>
const btnClick=e=>{}
<button onClick={this.btnClick>
```

### 使用原生事件

class组件在**componentDidMount中绑定原生事件**，但是需要注意的是，**在使用原生事件时，要在componentWillUnmount中手动移除，防止内存泄漏**

```javascript
class Test extends Component {
    componentDidMount() {
        this.refs.button.addEventListener('click',e=>{
            this.btnClick(e)
        })
    }
    btnClick(e){
        console.log(e);
    }
    componentWillUnmount() {
        this.refs.button.removeEventListener('click')
    }
    render() {
        return (
            <button ref='button'>test</button>
        );
    }
}
```

## SyntheticEvent和原生事件混用

合成事件内部仅仅只是把最外层的容器进行了绑定，并依赖事件的冒泡机制完成事件委派。事件并不会绑定到真实的div上，所有使用stopProppagation没有用。

**解决方案：**

1. **不要混用合成事件和原生事件**
2. **通过e?.target判断来避免**

此外用reactEvent.nativeEvent.stopPropagation()来阻止冒泡是不行的，**阻止react事件冒泡的行为只能用于react合成事件当中，且无法阻止dom原生事件；反之，在原生事件中阻止冒泡，可以阻止react合成事件冒泡**

**react的合成事件系统只是原生dom事件的子集。**有些方法还是需要用原生的dom事件完成，比如window的resize事件。

## 对比原生事件和合成事件

- **阻止事件传播与事件传播**

react只实现了阻止事件传播。

原生的事件传播分为三个阶段：事件捕获阶段---->目标对象本身的事件程序处理程序调用---->事件冒泡。

- **事件类型**

合成事件系统只是原生dom事件的子集。

- **事件绑定方式**

直接在dom上绑定、在js中，通过为元素的事件属性赋值的方式(el.onclick=e=>console.log(e))、通过事件监听函数（addEventListener(先绑定先执行)、attachEvent(IE,后绑定先执行)）

## 受控组件和非受控组件

尽量避免使用非受控组件

# 组件之间通信

## 父子之间通信

props

## 子父之间通信

回调函数

自定义事件机制

## 跨级组件通信

context,慎用，一般建议全局信息且不会更改，例如主题，用户信息，防止不知道context从哪里传过来。

## 无嵌套关系的组价之间

自定义事件

## 总结

Pub/Sub模式的实现简单，即用全局对象保存事件、用广播的方式处理事件，缺点是逻辑混乱。应当避免使用，加入强依赖和约定是更好的方法

# 组件间抽象

## mixin

### 引入minin的目的

早期是为了为了创造一种类似多继承的效果。知道es6引入class才向着标准化靠拢。

### 封装minin

广义的mixin方法，就是用赋值的方式将mixin对象里面的方法挂载到原对象上面，来实现对对象的混入。

```javascript
const mixin = (obj,mixins) => {
  const newObj=obj;
  newObj.prototype=Object.create(obj.prototype)
  for (const mixinsKey in mixins) {
    if (mixins.hasOwnProperty(mixinsKey)){
      newObj.prototype[mixinsKey]=mixins[mixinsKey]
    }
  }
}
```

### react中使用mixin

react在使用createClass构建组件时提供了mixin属性。比如**PureRenderMixin:**

```javascript
import React from 'react';
impotr PureRenderMixin from 'react-addons-pure-render-mixin';
React.createClass({
  mixin:[PureRenderMixin],
  render(){
return(<div>aaa</div>)
}
  )
```

mixin数组可增加多个mixin,**在不同的mixin实现两个相同的如同方法，后面的方法不会覆盖前面的方法，但是会报ReactClassInterface里面的错。因此，在React中不允许出现重名方法的mixin。**



**使用ReactClass实现mixin为组件做了两件事：**

- 共享一些工具方法
- 生命周期的继承，props和state合并。

### mixin缺点

- 破坏了组件原有的封装
- 命名冲突
- 增加复杂性

# 高阶组件

## 属性代理

**通过高阶组件来传递props，即为属性代理**



使用属性代理时，不同于mixin，类似于**堆栈调用：**

**didmount->HOC didmount->(HOCs didmount)->(HOCs will unmount)->HOC willunmount->unmount**

功能：

- 控制props

可以增加，移除，编辑传进来的props，**应尽可能对高阶组件的props做新的命名。**

- 通过refs使用引用
- 抽象state

高阶组件可以将原组件抽象为展示型组件，分离内部状态

- 使用其他元素包裹组件

**HOC与mixin不同：**

**高阶组件符合函数式编程的，对于原组件来说，并不会感知到高阶组件的存在，只需要把功能套在其之上，避免了使用mixin时产生的副作用。**

![](mixin.png)

## 反向继承

```javascript
const Test=(InputComponent)=>
  class extends InputComponent{
    render(){
      return super.render()
    }
```

如上，高阶组件的返回组件继承于InputComponent，因此被动的继承了InputComponent。方法可以通过super来调用，调用顺序与队列一致：

**didmount->HOC didmount->(HOCs didmount)->will unmount->HOC will unmount->(HOCs willunmount)**

- **渲染劫持**

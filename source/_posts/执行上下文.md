---
title: 执行上下文
tags:
  - JavaScript
top: true
cover: false
toc: true
mathjax: true
categories:
  - JavaScript
date: 2023-08-02 18:34:07
password:
summary:
  - JavaScript的执行上下文相关知识
---

{% blockquote  Sukhjinder Arora https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0 Understanding Execution Context and Execution Stack in Javascript %}
本文大部份内容引用翻译自Sukhjinder Arora的“了解 Javascript 中的执行上下文和执行堆栈”一文
{% endblockquote %}


# 什么是执行上下文

执行上下文：抽象概念，评估和执行js代码的环境。当前执行环境的变量、函数声明、作用链域、this等信息

# 执行上下文分类

1. **全局执行上下文**   这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 `this` 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。
2. **函数执行上下文** — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。
3. **Eval 函数执行上下文** — 执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 `eval`，所以在这里我不会讨论它。

# 执行栈

- js引擎第一次遇见js脚本，创建全局上下文，压栈；
- 遇到函数调用，创建函数上下文，压栈；
- 执行函数调用，出栈；
- 所有代码执行完毕，js引擎从当前栈移除全局上下文

```javascript
let a = 'Hello World!';

function first() {
  console.log('Inside first function');
  second();
  console.log('Again inside first function');
}

function second() {
  console.log('Inside second function');
}

first();
console.log('Inside Global Execution Context');
```
![执行栈图解](执行栈.jpg)

# 执行上下文的生命周期

## 创建阶段

执行上下文在创建阶段做两件事情：
创建词法环境组件（LexicalEnvironment）
创建变量环境组件（VariableEnvironment）

```javascript
ExecutionContext = {
  LexicalEnvironment = <ref. to LexicalEnvironment in memory>,
  VariableEnvironment = <ref. to VariableEnvironment in  memory>,
}
```

### 词法环境（LexicalEnvironment）

一种持有**标识符—变量映射**的结构。

- **标识符**指的是变量/函数的名字
- **变量**是对实际对象(包含函数类型对象)或原始数据的引用

```javascript
var a = 20;
var b = 40;
function foo() {
  console.log('bar');
}
```

上述代码的词法环境结构如下：

```javascript
lexicalEnvironment = {
  a: 20,
  b: 40,
  foo: <ref. to foo function>
}
```

### **词法环境的组成部分**：环境记录器、外部环境的引用、this绑定
![词法环境的组成部分](词法环境的组成部分.jpg)

#### **环境记录器**：环境记录是词法环境中存储变量和函数声明的地方
![环境记录器的组成部分](环境记录器.jpg)

{% blockquote %}
对于函数代码而言，环境记录还包含一个参数对象，该对象包含传递给函数的索引和参数之间的映射，以及传递给函数的参数长度（个数)。例如，下面函数的参数对象如下所示：
{% endblockquote %}

```javascript
function foo(a, b) {
  var c = a + b;
}
foo(2, 3);
// argument object
Arguments: {0: 2, 1: 3, length: 2},
```


#### **外部环境的引用：**

对外部环境的引用意味着它可以访问外部词法环境。
也就是说，如果当前词法环境中没有变量，JavaScript 引擎可以在外部环境中查找这些变量。

#### **this绑定：**

在该组成部分中，this 的值被确定或设置。

1. 在全局执行上下文中，this 的值指的是全局对象。(在浏览器中，它指的是窗口对象）。
2. 在函数执行上下文中，this 的值取决于函数的调用方式。如果函数是通过对象引用调用的，则 this 的值将设置为该对象；否则，this 的值将设置为全局对象或未定义（在严格模式下）

```javascript
const person = {
  name: 'peter',
  birthYear: 1994,
  calcAge: function() {
    console.log(2018 - this.birthYear);
  }
}
person.calcAge(); 
// 'this' refers to 'person', because 'calcAge' was called with //'person' object reference
const calculateAge = person.calcAge;
calculateAge();
// 'this' refers to the global window object, because no object reference was given
```

抽象地说，词法环境在伪代码中是这样的：

```javascript
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
    }
    outer: <null>,
    this: <global object>
  }
}
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
    }
    outer: <Global or outer function environment reference>,
    this: <depends on how function is called>
  }
}
```

### 可变环境

它也是一个词法环境，其 EnvironmentRecord 保存着 VariableStatements 在此执行上下文中创建的绑定。
**如上文所述，变量环境也是词法环境，因此它具有上文定义的词法环境的所有属性和组件。**
在 ES6 中，**LexicalEnvironment 组件与 VariableEnvironment 组件的区别在于，前者用于存储函数声明和变量（let 和 const）绑定，而后者仅用于存储变量（var）绑定。**

## 执行阶段

在此阶段，完成对所有这些变量的分配，最后执行代码。

```javascript
let a = 20;
const b = 30;
var c;
function multiply(e, f) {
 var g = 20;
 return e * f * g;
}
c = multiply(20, 30);
```

执行上述代码时，JavaScript 引擎会创建一个全局执行上下文来执行全局代码。因此，在创建阶段，全局执行上下文将是这样的：

```javascript
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      a: < uninitialized >,
      b: < uninitialized >,
      multiply: < func >
    }
    outer: <null>,
    ThisBinding: <Global Object>
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      c: undefined,
    }
    outer: <null>,
    ThisBinding: <Global Object>
  }
}
```

在执行阶段，变量赋值已经完成。因此，在执行阶段，全局执行上下文将如下所示。

```javascript
GlobalExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      a: 20,
      b: 30,
      multiply: < func >
    }
    outer: <null>,
    ThisBinding: <Global Object>
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      // Identifier bindings go here
      c: undefined,
    }
    outer: <null>,
    ThisBinding: <Global Object>
  }
}
```

当调用函数 multiply(20, 30) 时，会创建一个新的函数执行上下文来执行函数代码。因此，在创建阶段，函数执行上下文将如下所示：

```javascript
FunctionExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>,
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      g: undefined
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>
  }
}
```

在此之后，执行上下文将进入执行阶段，即完成对函数内部变量的赋值。因此，在执行阶段，函数的执行上下文将如下所示：

```javascript
FunctionExectionContext = {
LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      Arguments: {0: 20, 1: 30, length: 2},
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>,
  },
VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // Identifier bindings go here
      g: 20
    },
    outer: <GlobalLexicalEnvironment>,
    ThisBinding: <Global Object or undefined>
  }
}
```

函数完成后，返回值将存储在 c 中。之后，全局代码完成，程序结束。

注--你可能已经注意到，在创建阶段，let 和 const 定义的变量没有任何相关值，但 var 定义的变量被设置为未定义。
这是因为在创建阶段，代码会扫描变量和函数声明，而函数声明会完整地存储在环境中，变量最初会被设置为未定义（var 的情况）或保持未初始化（let 和 const 的情况）。
这就是为什么你可以在声明 var 定义变量之前访问它们（尽管它们未定义），但在声明 let 和 const 变量之前访问它们时会出现引用错误的原因。
这就是我们所说的挂起。
注意：在执行阶段，如果 JavaScript 引擎无法在源代码中声明 let 变量的实际位置找到它的值，就会将其赋值为 undefined。


# 执行上下文的特点

1. 单线程
2. 同步执行
3. 全局唯一
4. 函数每调用一次生成一个新的执行上下文环境